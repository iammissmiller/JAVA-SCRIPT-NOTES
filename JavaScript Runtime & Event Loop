**JavaScript Runtime & Event Loop**

This lecture explains **how asynchronous JavaScript works internally**, including:

* **Call Stack**
* **Web APIs**
* **Callback Queue**
* **Microtasks Queue**
* **Event Loop**
* **Promises vs Callbacks**
* **Why JS is async despite being single-threaded**

---

# 1Ô∏è‚É£ **JavaScript Runtime Components**

### ‚úî **1. JavaScript Engine**

* Executes code.
* Contains:

  * **Call Stack** ‚Üí where code runs
  * **Heap** ‚Üí where objects are stored
* JS is **single-threaded** ‚Üí only **one statement** executes at a time.

### ‚úî **2. Web APIs (Browser APIs)**

Not part of JS itself. Examples:

* DOM
* Timers (`setTimeout`)
* Fetch API
* Geolocation
* etc.

All **asynchronous tasks run here**, NOT in the JS engine.

### ‚úî **3. Callback Queue**

For callbacks coming from:

* setTimeout
* DOM events
* AJAX (older APIs)

### ‚úî **4. Microtasks Queue**

For:

* **Promise callbacks (`.then`, `.catch`)**
* **MutationObserver**
* and other microtasks.

**Microtasks ALWAYS run before callback queue tasks.**

### ‚úî **5. Event Loop**

* Constantly checks:

  * **Is the call stack empty?**
  * **If yes ‚Üí push microtasks first**
  * **Then push callbacks**

This is the heart of async JS.

---

# 2Ô∏è‚É£ **Why Asynchronous Code Works**

JS is single-threaded, BUT the browser is not.

* Browser runs async tasks (image loading, fetch, timers)
* JS engine continues running synchronously
* When async finishes ‚Üí browser sends callbacks back to JS (through queues)
* Event loop chooses when to execute them.

---

# 3Ô∏è‚É£ **Detailed Flow Example**

### Code used:

```js
const img = document.querySelector('.img');
img.src = 'dog.jpg';

img.addEventListener('load', function () {
  console.log('Image loaded');
});

fetch('https://api.com/data')
  .then(res => console.log('Data loaded'));
```

---

## ‚úî Step 1: DOM Image Starts Loading

`img.src = 'dog.jpg'`

* Loading image happens in **Web APIs**.
* Does NOT block the call stack.

---

## ‚úî Step 2: Event Listener Registered

`img.addEventListener('load', callback)`

* Stored in Web API environment.
* Will be executed when load event fires.

---

## ‚úî Step 3: Fetch Starts

`fetch(url)`

* Browser starts the network request.
* Promise is returned immediately.
* Fetch work runs in **Web APIs**, NOT JS engine.

---

## ‚úî Step 4: Image finishes loading ‚Üí ‚Äúload‚Äù event occurs

* Web API pushes the load callback into the **Callback Queue**.

---

## ‚úî Step 5: Fetch finishes ‚Üí Promise resolves

* Promise‚Äôs `.then()` callback goes into **Microtasks Queue** (NOT callback queue).

---

## ‚úî Step 6: Event Loop Behavior

### Event Loop Rule:

**Microtasks Queue ALWAYS empties BEFORE callback queue runs.**

Therefore:

1. Event loop sees stack empty
2. It checks **Microtasks Queue first**
3. Executes **fetch .then() callback**
4. THEN checks Callback Queue
5. Executes **image load callback**

‚û° **Promises have higher priority than DOM/timer callbacks.**

---

# 4Ô∏è‚É£ **Important Details**

### üìå **Timers are not guaranteed exact timing**

`setTimeout(() => {}, 5000)`
means:

* Callback will run *after at least* 5 seconds
* But might run LATER if:

  * call stack is busy
  * microtasks queue is busy
  * callback queue is full

---

### üìå **DOM events use callback queue**

Even though DOM events aren't asynchronous by nature ‚Üí their callbacks run through the queue.

---

### üìå **Microtasks can starve the callback queue**

If you keep adding more microtasks inside microtasks, callback queue will never run.

Example:

```js
Promise.resolve().then(() => Promise.resolve().then(() => {...}))
```

This can endlessly delay callback queue tasks.

---

# 5Ô∏è‚É£ **Simplified Execution Model**

### **When an async task finishes:**

| Type of Callback           | Goes To                          | Priority |
| -------------------------- | -------------------------------- | -------- |
| Promise handlers (`.then`) | Microtasks Queue                 | ‚≠ê High   |
| setTimeout / setInterval   | Callback Queue                   | Medium   |
| DOM Event Handlers         | Callback Queue                   | Medium   |
| UI Rendering               | After Microtasks Before Callback | Varies   |

---

# 6Ô∏è‚É£ **Key Concepts to Remember (Interview Essentials)**

### ‚úî JavaScript is **single-threaded**, **non-blocking**

### ‚úî Asynchronous tasks run in **Web APIs (Browser)**

### ‚úî When done ‚Üí callbacks are queued

### ‚úî Event Loop:

* First empties **Microtasks queue**
* Then processes **Callback queue**

### ‚úî Promises (.then) ALWAYS run before `setTimeout`, before DOM events

### ‚úî JS itself has **no concept of time**

Timers are managed by **Web APIs**, not JS.

---

# 7Ô∏è‚É£ **Why All This Matters**

Understanding the event loop makes you better at:

* Debugging async code
* Avoiding race conditions
* Knowing why Promises run before setTimeout
* Building performant apps
* Mastering async JavaScript (interview gold)
