**Classes — Public Interface & the Need for Data Encapsulation**

### **1. Creating a Class Example**

We create a class to model a **bank account**.

```js
class Account {
  constructor(owner, currency, pin) {
    this.owner = owner;
    this.currency = currency;
    this.pin = pin;
    // Properties not based on parameters
    this.movements = [];
    this.locale = navigator.language;

    console.log(`Thanks for opening an account, ${owner}!`);
  }
}
```

#### **Explanation:**

* `owner`, `currency`, and `pin` are **passed as arguments**.
* `movements` and `locale` are **set internally**:

  * `movements` → starts as an empty array.
  * `locale` → derived from the browser setting using `navigator.language`.
* The constructor can contain **any executable code** (like a welcome message).

---

### **2. Creating an Instance**

```js
const acc1 = new Account('Jonas', 'EUR', 1111);
```

Output:

```
Thanks for opening an account, Jonas!
```

---

### **3. Adding Movements (Deposits and Withdrawals)**

#### **Old way (bad practice):**

Directly manipulating properties:

```js
acc1.movements.push(250);
acc1.movements.push(-140);
```

This works, but it’s **not recommended**, as it allows **uncontrolled changes** to internal data.

---

### **4. Defining Methods for Deposits and Withdrawals**

Add methods inside the class to handle interactions properly:

```js
class Account {
  // ...constructor...

  deposit(value) {
    this.movements.push(value);
  }

  withdraw(value) {
    // Calls another method internally
    this.deposit(-value);
  }
}
```

#### **Explanation:**

* These methods **encapsulate** how money is added or removed.
* The `withdraw` method **abstracts** the idea that withdrawals are just negative movements — users no longer need to care about that.

---

### **5. Using the Methods (Public Interface)**

```js
acc1.deposit(250);
acc1.withdraw(140);
console.log(acc1.movements); // [250, -140]
```

✅ Cleaner and safer.
✅ Methods form the **public API** (or **public interface**) of the object.

---

### **6. Public Interface (API)**

* The **public interface** defines **how other code interacts** with an object.
* It exposes **specific methods** (like `deposit`, `withdraw`, `requestLoan`) while hiding internal logic or data.

```js
// Example of a public interface
acc1.deposit(250);
acc1.withdraw(140);
acc1.requestLoan(1000);
```

---

### **7. Abstraction Benefit**

* The `withdraw()` method hides internal logic.
* Users simply call `withdraw(140)` without needing to know withdrawals are negative numbers.
* This helps prevent **implementation details** from leaking outside the class.

---

### **8. Problem: Direct Access Still Possible**

Even with the public interface, some properties are still public:

```js
acc1.pin;        // Accessible — not secure
acc1.movements;  // Accessible — can be modified externally
```

⚠️ This violates **data privacy** and **encapsulation principles**.

---

### **9. Adding More Functionality: Requesting a Loan**

```js
class Account {
  // ... previous methods ...

  requestLoan(value) {
    if (this.approveLoan(value)) {
      this.deposit(value);
      console.log('Loan approved');
    }
  }

  approveLoan(value) {
    // Internal logic (for now, always true)
    return true;
  }
}
```

Usage:

```js
acc1.requestLoan(1000);
```

Output:

```
Loan approved
```

* The loan amount is added to the `movements` array.
* However, the **`approveLoan()` method** should **not** be accessible from outside:

  ```js
  acc1.approveLoan(1000); // Currently possible, but should not be
  ```

---

### **10. Motivation for Data Encapsulation & Privacy**

* Prevent **external code** from accessing or modifying internal properties/methods.
* Protect sensitive data (like PIN or balance).
* Hide internal logic (like loan approval conditions).
* Prevent accidental bugs caused by direct property manipulation.

---

### **11. Summary**

| Concept                             | Description                                       | Example                                |
| ----------------------------------- | ------------------------------------------------- | -------------------------------------- |
| **Class**                           | Blueprint for creating objects.                   | `class Account {}`                     |
| **Constructor**                     | Initializes properties when creating objects.     | `constructor(owner, currency, pin)`    |
| **Instance Properties**             | Data unique to each object.                       | `this.movements = []`                  |
| **Methods**                         | Functions that define the behavior (API).         | `deposit(), withdraw()`                |
| **Public Interface (API)**          | Methods available for use outside the object.     | `acc1.deposit(200)`                    |
| **Abstraction**                     | Hiding implementation details.                    | `withdraw()` hides negative push logic |
| **Encapsulation Need**              | Protect internal data from external modification. | `acc1.pin` should not be accessible    |
| **Private/Internal Method Example** | Should only be called internally.                 | `approveLoan()`                        |

---

### **12. Transition**

> Up next: **Implementing data encapsulation and privacy in classes**
> (using new class field syntax and private properties).
